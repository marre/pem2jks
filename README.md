# pem2jks

A pure Go utility to convert PEM certificates (like those generated by Kubernetes cert-manager) into Java KeyStore (JKS) or PKCS#12 format.

## Features

- Converts PEM certificates and private keys to JKS or PKCS#12 format
- Supports RSA and EC private keys
- Handles certificate chains
- **FIPS 140-2 compliant mode** - PKCS#12 output uses PBES2 with PBKDF2-HMAC-SHA-256 and AES-256-CBC
- **Supports multiple certificate/key pairs in a single keystore (JKS format)**
- **Supports multiple CA certificates from different files**
- **Can append to existing JKS and PKCS#12 keystores**
- Can create keystores (with private key) or truststores (CA certs only)
- Zero runtime dependencies - statically compiled
- Tiny container image (scratch base)
- Designed for Kubernetes sidecar/init container use

## FIPS 140-2 Compliance

pem2jks is available in two build variants:

### Standard Build (`pem2jks`)

The standard build supports both JKS and PKCS#12 formats:
- **JKS format**: Uses SHA-1 (not FIPS-compliant). A warning is displayed when used.
- **PKCS#12 format**: Uses FIPS-approved algorithms (PBES2 with PBKDF2-HMAC-SHA-256 and AES-256-CBC).

### FIPS Build (`pem2jks-fips`)

The FIPS build is a **FIPS 140-2 compliant** version that only supports PKCS#12 format:
- **Only PKCS#12 format is available** - JKS format is disabled at compile time
- **Uses FIPS-approved algorithms**:
  - **Encryption**: PBES2 (Password-Based Encryption Scheme 2) with PBKDF2-HMAC-SHA-256 and AES-256-CBC
  - **MAC**: HMAC-SHA-256
  - **Key Derivation**: PBKDF2 with SHA-256

### Usage

```bash
# Standard build - supports both formats
pem2jks -c tls.crt:tls.key -p changeit -f jks        # JKS (with warning)
pem2jks -c tls.crt:tls.key -p changeit -f pkcs12     # PKCS#12 (FIPS-compliant)

# FIPS build - only PKCS#12
pem2jks-fips -c tls.crt:tls.key -p changeit          # PKCS#12 (default)
pem2jks-fips -c tls.crt:tls.key -p changeit -f jks   # Error: JKS not available
```

**When to use FIPS build:**
- Environments requiring FIPS 140-2 compliance (e.g., government, regulated industries)
- When you want compile-time enforcement of FIPS-compliant formats
- When you need to prevent accidental use of non-FIPS formats

## Installation

### Download Pre-built Binaries

Pre-built binaries are available for Linux and macOS (both amd64 and arm64) from the [releases page](https://github.com/marre/pem2jks/releases).

**Two builds are available:**
- `pem2jks` - Standard build (supports both JKS and PKCS#12)
- `pem2jks-fips` - FIPS 140-2 compliant build (PKCS#12 only)

All binaries are signed using [Cosign](https://docs.sigstore.dev/cosign/overview/) and include SHA256 checksums for verification. See [Binary Verification Documentation](docs/BINARY-VERIFICATION.md) for instructions on how to verify signatures and checksums.

```bash
# Download latest release (example for Linux amd64)
VERSION="1.0.0"  # Replace with latest version

# Standard build
curl -LO https://github.com/marre/pem2jks/releases/download/v${VERSION}/pem2jks-linux-amd64

# FIPS build
curl -LO https://github.com/marre/pem2jks/releases/download/v${VERSION}/pem2jks-fips-linux-amd64

# Download checksums
curl -LO https://github.com/marre/pem2jks/releases/download/v${VERSION}/checksums.txt

# Verify checksum
sha256sum --ignore-missing -c checksums.txt

# Make executable and use
chmod +x pem2jks-linux-amd64
./pem2jks-linux-amd64 --help
```

### Using Docker

```bash
# Standard build
docker pull ghcr.io/marre/pem2jks:latest
docker run --rm ghcr.io/marre/pem2jks:latest --help

# FIPS build
docker pull ghcr.io/marre/pem2jks-fips:latest
docker run --rm ghcr.io/marre/pem2jks-fips:latest --help
```

All Docker images are also signed with Cosign. See the [Kubernetes Usage](#kubernetes-usage) section below for signature verification instructions.

### Build from Source

```bash
git clone https://github.com/marre/pem2jks.git
cd pem2jks
make build
./bin/pem2jks --help
```

## Usage

### Basic Examples

```bash
# Create JKS keystore with private key and certificate
pem2jks -c tls.crt:tls.key -p changeit -o keystore.jks

# Create PKCS#12 keystore (FIPS-compliant)
pem2jks -c tls.crt:tls.key -p changeit -o keystore.p12 -f pkcs12

# Or use FIPS build which only supports PKCS#12
pem2jks-fips -c tls.crt:tls.key -p changeit

# Create keystore with multiple cert/key pairs and custom aliases
pem2jks -c app1.crt:app1.key:app1 \
        -c app2.crt:app2.key:app2 \
        -p changeit

# Mix private key entry with cert-only trusted certificates
pem2jks -c tls.crt:tls.key:server \
        -c ca1.crt::ca1 \
        -c ca2.crt::ca2 \
        -p changeit

# Create keystore with certificate chain and additional CAs
pem2jks -c tls.crt:tls.key --ca ca1.crt:root --ca ca2.crt:intermediate -p changeit

# Create truststore (CA certs only, no private key)
pem2jks --ca ca.crt:my-ca -p changeit -o truststore.jks

# Use environment variable for password
export KEYSTORE_PASSWORD=changeit
pem2jks -c tls.crt:tls.key
```

### Appending to Existing Keystores

```bash
# Add certificates to existing JKS keystore with same password
pem2jks --input existing.jks -c new.crt:new.key:newcert -p changeit

# Add certificates to existing JKS with different input/output passwords
pem2jks --input existing.jks --input-password oldpass \
        -c new.crt:new.key:newcert -p newpass

# Add CA certificates to existing PKCS#12 truststore
pem2jks --input truststore.p12 --ca new-ca.crt:newca \
        -p changeit -f pkcs12
```

### Entry Format

**Certificate/Key entries (`--cert` or `-c`):**
- `cert.pem:key.pem:alias` - Certificate + key with custom alias
- `cert.pem:key.pem` - Certificate + key (auto-alias: server, server-1, ...)
- `cert.pem::alias` - Certificate only (trusted cert) with custom alias
- `cert.pem::` - Certificate only (trusted cert) with auto-alias

**CA certificates (`--ca`):**
- `ca.pem:alias` - CA certificate with custom alias
- `ca.pem` - CA certificate (auto-alias: ca, ca-1, ca-2, ...)

### Commands

```bash
# Show version
pem2jks version

# Show help
pem2jks --help
```

### Options

| Option | Short | Description |
|--------|-------|-------------|
| `--cert` | `-c` | Certificate and key entry in format `cert.pem[:key.pem[:alias]]` (repeatable) |
| `--ca` | | CA certificate in format `ca.pem[:alias]` (repeatable) |
| `--input` | `-i` | Existing keystore file to append to (supports both JKS and PKCS#12) |
| `--input-password` | | Password for input keystore (defaults to `--password` if not specified) |
| `--output` | `-o` | Output keystore file path (default based on format) |
| `--password` | `-p` | Keystore password |
| `--password-file` | | File containing keystore password |
| `--format` | `-f` | Output format: `jks` or `pkcs12` (default: jks for standard build, pkcs12 for FIPS build) |
| `--help` | `-h` | Show help |

### Limitations

- **Multiple private keys in PKCS#12**: The PKCS#12 format only supports one private key entry per keystore. For multiple private keys, use JKS format or create separate PKCS#12 keystores.
- **Duplicate aliases**: When appending to an existing keystore, duplicate aliases (case-insensitive) will cause an error to prevent overwriting existing entries.

### Environment Variables

| Variable | Description |
|----------|-------------|
| `KEYSTORE_PASSWORD` | Keystore password (lowest priority) |

### Output Formats

| Format | Description | Use Case | FIPS 140-2 Compliant |
|--------|-------------|----------|----------------------|
| `jks` | Java KeyStore (uses SHA-1) | Traditional Java applications | ❌ No (not available in FIPS build) |
| `pkcs12` | PKCS#12 (uses PBES2 with SHA-256) | Modern applications, cross-platform, FIPS environments | ✅ Yes |

## Kubernetes Usage

### Docker Image Security

All Docker images published as part of releases are signed using [Cosign](https://docs.sigstore.dev/cosign/overview/) with keyless signing (OIDC-based). This ensures the authenticity and integrity of the images.

#### Verifying Image Signatures

To verify the signature of a Docker image before using it:

```bash
# Install Cosign (if not already installed)
# See: https://docs.sigstore.dev/cosign/installation/

# Verify the latest image
cosign verify ghcr.io/marre/pem2jks:latest \
  --certificate-identity-regexp="https://github.com/marre/pem2jks/.*" \
  --certificate-oidc-issuer="https://token.actions.githubusercontent.com"

# Verify a specific version
cosign verify ghcr.io/marre/pem2jks:1.0.0 \
  --certificate-identity-regexp="https://github.com/marre/pem2jks/.*" \
  --certificate-oidc-issuer="https://token.actions.githubusercontent.com"
```

The verification confirms that the image was built and signed by the official GitHub Actions workflow in this repository.

For more details about image signing, verification, and Kubernetes admission control policies, see [Docker Image Signing Documentation](docs/DOCKER-IMAGE-SIGNING.md).

### As an Init Container

#### FIPS 140-2 Compliant (Recommended for Regulated Environments)

Use the `pem2jks-fips` Docker image for guaranteed FIPS compliance:

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: java-app-fips
spec:
  initContainers:
    - name: cert-converter
      image: ghcr.io/marre/pem2jks-fips:latest
      args:
        - -c
        - /certs/tls.crt:/certs/tls.key:myapp
        - --ca
        - /certs/ca.crt
        - --password-file=/secrets/keystore-password
        - --output=/keystore/keystore.p12
      volumeMounts:
        - name: certs
          mountPath: /certs
          readOnly: true
        - name: keystore
          mountPath: /keystore
        - name: secrets
          mountPath: /secrets
          readOnly: true
  containers:
    - name: java-app
      image: my-java-app:latest
      env:
        - name: KEYSTORE_PASSWORD
          valueFrom:
            secretKeyRef:
              name: keystore-password
              key: password
        - name: JAVA_OPTS
          value: "-Djavax.net.ssl.keyStore=/keystore/keystore.p12 -Djavax.net.ssl.keyStorePassword=$(KEYSTORE_PASSWORD) -Djavax.net.ssl.keyStoreType=PKCS12"
      volumeMounts:
        - name: keystore
          mountPath: /keystore
          readOnly: true
  volumes:
    - name: certs
      secret:
        secretName: my-tls-cert  # Created by cert-manager
    - name: keystore
      emptyDir: {}
    - name: secrets
      secret:
        secretName: keystore-password
```

#### PKCS#12 Format

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: java-app
spec:
  initContainers:
    - name: cert-converter
      image: ghcr.io/marre/pem2jks:latest
      args:
        - -c
        - /certs/tls.crt:/certs/tls.key:myapp
        - --ca
        - /certs/ca.crt
        - --password-file=/secrets/keystore-password
        - --output=/keystore/keystore.p12
        - --format=pkcs12
      volumeMounts:
        - name: certs
          mountPath: /certs
          readOnly: true
        - name: keystore
          mountPath: /keystore
        - name: secrets
          mountPath: /secrets
          readOnly: true
  containers:
    - name: java-app
      image: my-java-app:latest
      env:
        - name: KEYSTORE_PASSWORD
          valueFrom:
            secretKeyRef:
              name: keystore-password
              key: password
        - name: JAVA_OPTS
          value: "-Djavax.net.ssl.keyStore=/keystore/keystore.p12 -Djavax.net.ssl.keyStorePassword=$(KEYSTORE_PASSWORD)"
      volumeMounts:
        - name: keystore
          mountPath: /keystore
          readOnly: true
  volumes:
    - name: certs
      secret:
        secretName: my-tls-cert  # Created by cert-manager
    - name: keystore
      emptyDir: {}
    - name: secrets
      secret:
        secretName: keystore-password
```

#### JKS Format

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: java-app
spec:
  initContainers:
    - name: cert-converter
      image: ghcr.io/marre/pem2jks:latest
      args:
        - -c
        - /certs/tls.crt:/certs/tls.key:myapp
        - --ca
        - /certs/ca.crt
        - --password-file=/secrets/keystore-password
        - --output=/keystore/keystore.jks
      volumeMounts:
        - name: certs
          mountPath: /certs
          readOnly: true
        - name: keystore
          mountPath: /keystore
        - name: secrets
          mountPath: /secrets
          readOnly: true
  containers:
    - name: java-app
      image: my-java-app:latest
      env:
        - name: KEYSTORE_PASSWORD
          valueFrom:
            secretKeyRef:
              name: keystore-password
              key: password
        - name: JAVA_OPTS
          value: "-Djavax.net.ssl.keyStore=/keystore/keystore.jks -Djavax.net.ssl.keyStorePassword=$(KEYSTORE_PASSWORD)"
      volumeMounts:
        - name: keystore
          mountPath: /keystore
          readOnly: true
  volumes:
    - name: certs
      secret:
        secretName: my-tls-cert  # Created by cert-manager
    - name: keystore
      emptyDir: {}
    - name: secrets
      secret:
        secretName: keystore-password
```

### With cert-manager Certificate

```yaml
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: my-tls-cert
spec:
  secretName: my-tls-cert
  issuerRef:
    name: my-issuer
    kind: ClusterIssuer
  commonName: myapp.example.com
  dnsNames:
  - myapp.example.com
```

## Input Formats

### Certificate (tls.crt)

PEM-encoded X.509 certificate. May contain certificate chain:

```
-----BEGIN CERTIFICATE-----
MIIDg...
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIDf... (intermediate CA)
-----END CERTIFICATE-----
```

### Private Key (tls.key)

PEM-encoded private key. Supports:
- PKCS#8 (`-----BEGIN PRIVATE KEY-----`)
- PKCS#1 RSA (`-----BEGIN RSA PRIVATE KEY-----`)
- SEC1 EC (`-----BEGIN EC PRIVATE KEY-----`)

### CA Certificate (ca.crt)

PEM-encoded CA certificate(s):

```
-----BEGIN CERTIFICATE-----
MIIDh... (CA cert)
-----END CERTIFICATE-----
```

## Development

### Building from Source

```bash
# Run all checks and build
make all

# Build the binary
make build

# Run unit tests
make test

# Run integration tests (requires Docker)
make test-integration

# Format and lint code
make lint

# Clean build artifacts
make clean

# Show all available targets
make help
```

### Docker Images

```bash
# Build Docker image locally
make docker
```

The `Dockerfile` is a minimal scratch-based image that copies the pre-built binary. Release images are built, pushed, and signed automatically by [GoReleaser](https://goreleaser.com/) using Docker Buildx.

## License

Apache License 2.0 - see [LICENSE.txt](LICENSE.txt) for details.
