# pem2jks

A pure Go utility to convert PEM certificates (like those generated by Kubernetes cert-manager) into Java KeyStore (JKS) or PKCS#12 format.

## Features

- Converts PEM certificates and private keys to JKS or PKCS#12 format
- Supports RSA and EC private keys
- Handles certificate chains
- **Supports multiple certificate/key pairs in a single keystore (JKS format)**
- **Supports multiple CA certificates from different files**
- **Can append to existing JKS and PKCS#12 keystores**
- Can create keystores (with private key) or truststores (CA certs only)
- PKCS#12 legacy mode for compatibility with older Java versions
- Zero runtime dependencies - statically compiled
- Tiny container image (scratch base)
- Designed for Kubernetes sidecar/init container use

## Usage

```bash
# Create JKS keystore (default format)
pem2jks -c tls.crt -k tls.key -p changeit -o keystore.jks

# Create PKCS#12 keystore
pem2jks -c tls.crt -k tls.key -p changeit -o keystore.p12 -f pkcs12

# Create PKCS#12 with legacy algorithms (for older Java versions)
pem2jks -c tls.crt -k tls.key -p changeit -f pkcs12 --legacy

# Create keystore with certificate chain and CA
pem2jks -c tls.crt -k tls.key --ca ca.crt -p changeit

# Create keystore with multiple cert/key pairs (JKS only)
pem2jks -c app1.crt -k app1.key -a app1 \
        -c app2.crt -k app2.key -a app2 \
        -p changeit

# Create keystore with multiple CA certificates
pem2jks --ca ca1.crt --ca ca2.crt --ca ca3.crt -p changeit -f pkcs12

# Add certificates to existing JKS keystore
pem2jks --input existing.jks -c new.crt -k new.key -a newcert -p changeit

# Add certificates to existing PKCS#12 keystore
pem2jks --input existing.p12 -c new.crt -k new.key -a newcert -p changeit -f pkcs12

# Add CA certificates to existing JKS truststore
pem2jks --input truststore.jks --ca ca2.crt -p changeit -o updated-truststore.jks

# Add CA certificates to existing PKCS#12 truststore
pem2jks --input truststore.p12 --ca ca2.crt -p changeit -f pkcs12 -o updated-truststore.p12

# Create truststore (CA certs only, no private key)
pem2jks --ca ca.crt -p changeit -o truststore.jks

# Use environment variable for password
export KEYSTORE_PASSWORD=changeit
pem2jks -c tls.crt -k tls.key

# Show version
pem2jks version

# Show help
pem2jks --help
```

### Options

| Option | Short | Description |
|--------|-------|-------------|
| `--cert` | `-c` | Path to certificate PEM file (repeatable for multiple certs) |
| `--key` | `-k` | Path to private key PEM file (repeatable, must match cert count) |
| `--ca` | | Path to CA certificate PEM file (repeatable) |
| `--input` | `-i` | Existing keystore file to append to (supports both JKS and PKCS#12) |
| `--output` | `-o` | Output keystore file path (default based on format) |
| `--password` | `-p` | Keystore password |
| `--password-file` | | File containing keystore password |
| `--alias` | `-a` | Alias for the private key entry (repeatable, default: server, server-1, ...) |
| `--format` | `-f` | Output format: `jks` or `pkcs12` (default: jks) |
| `--legacy` | | Use legacy PKCS#12 algorithms (for older Java) |
| `--help` | `-h` | Show help |

### Commands

| Command | Description |
|---------|-------------|
| `version` | Show version information |

### Limitations

- **Multiple private keys in PKCS#12**: The PKCS#12 format only supports one private key entry per keystore. For multiple private keys, use JKS format or create separate PKCS#12 keystores.
- When using `--input` to append to an existing keystore, the password for the existing keystore must match the password specified with `-p`, `--password-file`, or `KEYSTORE_PASSWORD`.

### Environment Variables

| Variable | Description |
|----------|-------------|
| `KEYSTORE_PASSWORD` | Keystore password (lowest priority) |

### Output Formats

| Format | Description | Use Case |
|--------|-------------|----------|
| `jks` | Java KeyStore | Traditional Java applications |
| `pkcs12` | PKCS#12 (modern) | Modern applications, cross-platform |
| `pkcs12 --legacy` | PKCS#12 (legacy) | Older Java (< 8u301), legacy systems |

## Kubernetes Usage

### Docker Image Security

All Docker images published as part of releases are signed using [Cosign](https://docs.sigstore.dev/cosign/overview/) with keyless signing (OIDC-based). This ensures the authenticity and integrity of the images.

#### Verifying Image Signatures

To verify the signature of a Docker image before using it:

```bash
# Install Cosign (if not already installed)
# See: https://docs.sigstore.dev/cosign/installation/

# Verify the latest image
cosign verify ghcr.io/marre/pem2jks:latest \
  --certificate-identity-regexp="https://github.com/marre/pem2jks/.*" \
  --certificate-oidc-issuer="https://token.actions.githubusercontent.com"

# Verify a specific version
cosign verify ghcr.io/marre/pem2jks:1.0.0 \
  --certificate-identity-regexp="https://github.com/marre/pem2jks/.*" \
  --certificate-oidc-issuer="https://token.actions.githubusercontent.com"
```

The verification confirms that the image was built and signed by the official GitHub Actions workflow in this repository.

For more details about image signing, verification, and Kubernetes admission control policies, see [Docker Image Signing Documentation](docs/DOCKER-IMAGE-SIGNING.md).

### As an Init Container

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: java-app
spec:
  initContainers:
  - name: cert-converter
    image: ghcr.io/marre/pem2jks:latest
    args:
      - --cert=/certs/tls.crt
      - --key=/certs/tls.key
      - --ca=/certs/ca.crt
      - --alias=myapp
      - --password-file=/secrets/keystore-password
      - --output=/keystore/keystore.p12
      - --format=pkcs12
    volumeMounts:
    - name: certs
      mountPath: /certs
      readOnly: true
    - name: keystore
      mountPath: /keystore
    - name: secrets
      mountPath: /secrets
      readOnly: true
  containers:
  - name: java-app
    image: my-java-app:latest
    env:
    - name: JAVA_OPTS
      value: "-Djavax.net.ssl.keyStore=/keystore/keystore.jks -Djavax.net.ssl.keyStorePassword=changeit"
    volumeMounts:
    - name: keystore
      mountPath: /keystore
      readOnly: true
  volumes:
  - name: certs
    secret:
      secretName: my-tls-cert  # Created by cert-manager
  - name: keystore
    emptyDir: {}
  - name: secrets
    secret:
      secretName: keystore-password
```

### With cert-manager Certificate

```yaml
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: my-tls-cert
spec:
  secretName: my-tls-cert
  issuerRef:
    name: my-issuer
    kind: ClusterIssuer
  commonName: myapp.example.com
  dnsNames:
  - myapp.example.com
```

## Input Formats

### Certificate (tls.crt)

PEM-encoded X.509 certificate. May contain certificate chain:

```
-----BEGIN CERTIFICATE-----
MIIDg...
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIDf... (intermediate CA)
-----END CERTIFICATE-----
```

### Private Key (tls.key)

PEM-encoded private key. Supports:
- PKCS#8 (`-----BEGIN PRIVATE KEY-----`)
- PKCS#1 RSA (`-----BEGIN RSA PRIVATE KEY-----`)
- SEC1 EC (`-----BEGIN EC PRIVATE KEY-----`)

### CA Certificate (ca.crt)

PEM-encoded CA certificate(s):

```
-----BEGIN CERTIFICATE-----
MIIDh... (CA cert)
-----END CERTIFICATE-----
```

## Development

```bash
# Run all checks and build
make all

# Build the binary
make build

# Run unit tests
make test

# Run integration tests (requires Java JDK for keytool)
make test-integration

# Format and lint code
make lint

# Build Docker image
make docker

# Clean build artifacts
make clean

# Show all available targets
make help
```

## License

Apache License 2.0 - see [LICENSE.txt](LICENSE.txt) for details.
