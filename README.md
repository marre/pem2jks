# pem2jks

A pure Go utility to convert PEM certificates (like those generated by Kubernetes cert-manager) into Java KeyStore (JKS) or PKCS#12 format.

## Features

- Converts PEM certificates and private keys to JKS or PKCS#12 format
- Supports RSA and EC private keys
- Handles certificate chains
- **Supports multiple certificate/key pairs in a single keystore (JKS format)**
- **Supports multiple CA certificates from different files**
- **Can append to existing JKS and PKCS#12 keystores**
- Can create keystores (with private key) or truststores (CA certs only)
- Zero runtime dependencies - statically compiled
- Tiny container image (scratch base)
- Designed for Kubernetes sidecar/init container use

## Installation

### Download Pre-built Binaries

Pre-built binaries are available for Linux and macOS (both amd64 and arm64) from the [releases page](https://github.com/marre/pem2jks/releases).

All binaries are signed using [Cosign](https://docs.sigstore.dev/cosign/overview/) and include SHA256 checksums for verification. See [Binary Verification Documentation](docs/BINARY-VERIFICATION.md) for instructions on how to verify signatures and checksums.

```bash
# Download latest release (example for Linux amd64)
VERSION="1.0.0"  # Replace with latest version
curl -LO https://github.com/marre/pem2jks/releases/download/v${VERSION}/pem2jks-linux-amd64.tar.gz
curl -LO https://github.com/marre/pem2jks/releases/download/v${VERSION}/pem2jks-linux-amd64.tar.gz.sha256

# Verify checksum
sha256sum -c pem2jks-linux-amd64.tar.gz.sha256

# Extract and use
tar -xzf pem2jks-linux-amd64.tar.gz
./pem2jks-linux-amd64 --help
```

### Using Docker

```bash
# Pull the latest image
docker pull ghcr.io/marre/pem2jks:latest

# Run with Docker
docker run --rm ghcr.io/marre/pem2jks:latest --help
```

All Docker images are also signed with Cosign. See the [Kubernetes Usage](#kubernetes-usage) section below for signature verification instructions.

### Build from Source

```bash
git clone https://github.com/marre/pem2jks.git
cd pem2jks
make build
./bin/pem2jks --help
```

## Usage

### Basic Examples

```bash
# Create JKS keystore with private key and certificate
pem2jks -c tls.crt:tls.key -p changeit -o keystore.jks

# Create PKCS#12 keystore
pem2jks -c tls.crt:tls.key -p changeit -o keystore.p12 -f pkcs12

# Create keystore with multiple cert/key pairs and custom aliases
pem2jks -c app1.crt:app1.key:app1 \
        -c app2.crt:app2.key:app2 \
        -p changeit

# Mix private key entry with cert-only trusted certificates
pem2jks -c tls.crt:tls.key:server \
        -c ca1.crt::ca1 \
        -c ca2.crt::ca2 \
        -p changeit

# Create keystore with certificate chain and additional CAs
pem2jks -c tls.crt:tls.key --ca ca1.crt:root --ca ca2.crt:intermediate -p changeit

# Create truststore (CA certs only, no private key)
pem2jks --ca ca.crt:my-ca -p changeit -o truststore.jks

# Use environment variable for password
export KEYSTORE_PASSWORD=changeit
pem2jks -c tls.crt:tls.key
```

### Appending to Existing Keystores

```bash
# Add certificates to existing JKS keystore with same password
pem2jks --input existing.jks -c new.crt:new.key:newcert -p changeit

# Add certificates to existing JKS with different input/output passwords
pem2jks --input existing.jks --input-password oldpass \
        -c new.crt:new.key:newcert -p newpass

# Add CA certificates to existing PKCS#12 truststore
pem2jks --input truststore.p12 --ca new-ca.crt:newca \
        -p changeit -f pkcs12
```

### Entry Format

**Certificate/Key entries (`--cert` or `-c`):**
- `cert.pem:key.pem:alias` - Certificate + key with custom alias
- `cert.pem:key.pem` - Certificate + key (auto-alias: server, server-1, ...)
- `cert.pem::alias` - Certificate only (trusted cert) with custom alias
- `cert.pem::` - Certificate only (trusted cert) with auto-alias

**CA certificates (`--ca`):**
- `ca.pem:alias` - CA certificate with custom alias
- `ca.pem` - CA certificate (auto-alias: ca, ca-1, ca-2, ...)

### Commands

```bash
# Show version
pem2jks version

# Show help
pem2jks --help
```

### Options

| Option | Short | Description |
|--------|-------|-------------|
| `--cert` | `-c` | Certificate and key entry in format `cert.pem[:key.pem[:alias]]` (repeatable) |
| `--ca` | | CA certificate in format `ca.pem[:alias]` (repeatable) |
| `--input` | `-i` | Existing keystore file to append to (supports both JKS and PKCS#12) |
| `--input-password` | | Password for input keystore (defaults to `--password` if not specified) |
| `--output` | `-o` | Output keystore file path (default based on format) |
| `--password` | `-p` | Keystore password |
| `--password-file` | | File containing keystore password |
| `--format` | `-f` | Output format: `jks` or `pkcs12` (default: jks) |
| `--help` | `-h` | Show help |

### Limitations

- **Multiple private keys in PKCS#12**: The PKCS#12 format only supports one private key entry per keystore. For multiple private keys, use JKS format or create separate PKCS#12 keystores.
- **Duplicate aliases**: When appending to an existing keystore, duplicate aliases (case-insensitive) will cause an error to prevent overwriting existing entries.

### Environment Variables

| Variable | Description |
|----------|-------------|
| `KEYSTORE_PASSWORD` | Keystore password (lowest priority) |

### Output Formats

| Format | Description | Use Case |
|--------|-------------|----------|
| `jks` | Java KeyStore | Traditional Java applications |
| `pkcs12` | PKCS#12 | Modern applications, cross-platform |

## Kubernetes Usage

### Docker Image Security

All Docker images published as part of releases are signed using [Cosign](https://docs.sigstore.dev/cosign/overview/) with keyless signing (OIDC-based). This ensures the authenticity and integrity of the images.

#### Verifying Image Signatures

To verify the signature of a Docker image before using it:

```bash
# Install Cosign (if not already installed)
# See: https://docs.sigstore.dev/cosign/installation/

# Verify the latest image
cosign verify ghcr.io/marre/pem2jks:latest \
  --certificate-identity-regexp="https://github.com/marre/pem2jks/.*" \
  --certificate-oidc-issuer="https://token.actions.githubusercontent.com"

# Verify a specific version
cosign verify ghcr.io/marre/pem2jks:1.0.0 \
  --certificate-identity-regexp="https://github.com/marre/pem2jks/.*" \
  --certificate-oidc-issuer="https://token.actions.githubusercontent.com"
```

The verification confirms that the image was built and signed by the official GitHub Actions workflow in this repository.

For more details about image signing, verification, and Kubernetes admission control policies, see [Docker Image Signing Documentation](docs/DOCKER-IMAGE-SIGNING.md).

### As an Init Container

#### PKCS#12 Format

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: java-app
spec:
  initContainers:
    - name: cert-converter
      image: ghcr.io/marre/pem2jks:latest
      args:
        - -c
        - /certs/tls.crt:/certs/tls.key:myapp
        - --ca
        - /certs/ca.crt
        - --password-file=/secrets/keystore-password
        - --output=/keystore/keystore.p12
        - --format=pkcs12
      volumeMounts:
        - name: certs
          mountPath: /certs
          readOnly: true
        - name: keystore
          mountPath: /keystore
        - name: secrets
          mountPath: /secrets
          readOnly: true
  containers:
    - name: java-app
      image: my-java-app:latest
      env:
        - name: KEYSTORE_PASSWORD
          valueFrom:
            secretKeyRef:
              name: keystore-password
              key: password
        - name: JAVA_OPTS
          value: "-Djavax.net.ssl.keyStore=/keystore/keystore.p12 -Djavax.net.ssl.keyStorePassword=$(KEYSTORE_PASSWORD)"
      volumeMounts:
        - name: keystore
          mountPath: /keystore
          readOnly: true
  volumes:
    - name: certs
      secret:
        secretName: my-tls-cert  # Created by cert-manager
    - name: keystore
      emptyDir: {}
    - name: secrets
      secret:
        secretName: keystore-password
```

#### JKS Format

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: java-app
spec:
  initContainers:
    - name: cert-converter
      image: ghcr.io/marre/pem2jks:latest
      args:
        - -c
        - /certs/tls.crt:/certs/tls.key:myapp
        - --ca
        - /certs/ca.crt
        - --password-file=/secrets/keystore-password
        - --output=/keystore/keystore.jks
      volumeMounts:
        - name: certs
          mountPath: /certs
          readOnly: true
        - name: keystore
          mountPath: /keystore
        - name: secrets
          mountPath: /secrets
          readOnly: true
  containers:
    - name: java-app
      image: my-java-app:latest
      env:
        - name: KEYSTORE_PASSWORD
          valueFrom:
            secretKeyRef:
              name: keystore-password
              key: password
        - name: JAVA_OPTS
          value: "-Djavax.net.ssl.keyStore=/keystore/keystore.jks -Djavax.net.ssl.keyStorePassword=$(KEYSTORE_PASSWORD)"
      volumeMounts:
        - name: keystore
          mountPath: /keystore
          readOnly: true
  volumes:
    - name: certs
      secret:
        secretName: my-tls-cert  # Created by cert-manager
    - name: keystore
      emptyDir: {}
    - name: secrets
      secret:
        secretName: keystore-password
```

### With cert-manager Certificate

```yaml
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: my-tls-cert
spec:
  secretName: my-tls-cert
  issuerRef:
    name: my-issuer
    kind: ClusterIssuer
  commonName: myapp.example.com
  dnsNames:
  - myapp.example.com
```

## Input Formats

### Certificate (tls.crt)

PEM-encoded X.509 certificate. May contain certificate chain:

```
-----BEGIN CERTIFICATE-----
MIIDg...
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIDf... (intermediate CA)
-----END CERTIFICATE-----
```

### Private Key (tls.key)

PEM-encoded private key. Supports:
- PKCS#8 (`-----BEGIN PRIVATE KEY-----`)
- PKCS#1 RSA (`-----BEGIN RSA PRIVATE KEY-----`)
- SEC1 EC (`-----BEGIN EC PRIVATE KEY-----`)

### CA Certificate (ca.crt)

PEM-encoded CA certificate(s):

```
-----BEGIN CERTIFICATE-----
MIIDh... (CA cert)
-----END CERTIFICATE-----
```

## Development

### Building from Source

```bash
# Run all checks and build
make all

# Build the binary
make build

# Run unit tests
make test

# Run integration tests (requires Java JDK for keytool)
make test-integration

# Format and lint code
make lint

# Clean build artifacts
make clean

# Show all available targets
make help
```

### Docker Images

The repository provides two Dockerfiles for different use cases:

#### `Dockerfile` (Production)
Used for official releases. This Dockerfile:
- Uses pre-built, signed binaries from the build context (provided by the release workflow)
- Verifies SHA256 checksums
- Verifies Cosign signatures
- Ensures maximum security and reproducibility

**Note:** This Dockerfile requires signed binaries in the build context and is used by the release workflow.

#### `Dockerfile.dev` (Development)
Used for local development and testing. This Dockerfile:
- Builds the binary from source code
- Suitable for local development without signed binaries
- Faster iteration during development

```bash
# Build development Docker image (builds from source)
make docker-dev

# Build multi-arch Docker images for development
make docker-multiarch

# Build and push multi-arch Docker images
make docker-push
```

## License

Apache License 2.0 - see [LICENSE.txt](LICENSE.txt) for details.
